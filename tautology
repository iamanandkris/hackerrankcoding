object listetsest {
  println("Welcome to the Scala worksheet")
  val str = "((((((((((a&(!b|b))|(!a&(!b|b)))|c)|d)|e)|f)|g)|h)|i)|j)".replaceAll(" ", "")
  val distStr = str.distinct
  val k = distStr.foldLeft(List[Char]())((a, b) => {
    if (b.isLetter) a ::: List(b)
    else a
  })

  val p = (1 to k.length).toList
  val m = List.fill(k.length)(0)
  val roots = p.map { x => p.map { y => { if (x < y) 0 else 1 } } }
  val allTrueFalses = m :: roots.flatMap { x => x.permutations }
  allTrueFalses.size
  val zippedTrueFalse = allTrueFalses.map { x =>
    {
      val zipped = x zip k
      zipped
    }
  }

  val allPossibleTrueAndFalseValues = zippedTrueFalse.map(f => {
    f.foldLeft(str)((a, b) => {
      a.replace(b._2.toString, b._1.toString())
    })
  })
  val reductionSequence = List(("!0", "1"), ("!1", "0"), ("(1&0)", "0"), ("(0&1)", "0"), ("(0&0)", "0"), ("(1&1)", "1"), ("(1|0)", "1"), ("(0|1)", "1"), ("(1|1)", "1"), ("(0|0)", "0"))
  allPossibleTrueAndFalseValues.size

  def reduceIt(inputSeq: String): String = {
    if (inputSeq.length() == 1) inputSeq
    else {
      val kk = reductionSequence.foldLeft(inputSeq)((a, b) => {
        a.replaceAllLiterally(b._1, b._2)
      })

      reduceIt(kk)
    }
  }

  def calcFinalRes(lstStr: List[String]): Boolean = {
    def intermediate(lstStrTemp: List[String], accum: Boolean): Boolean = {
      lstStrTemp match {
        case x :: y => {
          if (accum && (reduceIt(x) == "1")) {
            intermediate(y, true)
          } else {
            false
          }
        }
        case Nil => accum
      }

    }
    intermediate(lstStr, true)
  }

  calcFinalRes(allPossibleTrueAndFalseValues)
}
